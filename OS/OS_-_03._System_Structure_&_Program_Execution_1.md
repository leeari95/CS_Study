# OS - 03. System Structure & Program Execution 1

 > 본 글은 반효경 교수님의 [운영체제 강의(2014)](http://www.kocw.net/home/search/kemView.do?kemId=1046323) 내용에 대해 학습하고 정리한 내용입니다. 

# 컴퓨터 시스템 구조

![](https://i.imgur.com/UwAR0s0.png)

![](https://i.imgur.com/2fUaTWk.png)

* 메모리
    * `CPU의 작업 공간`을 의미한다. 뭔가 일을 하려면 CPU의 기계어를 실행한다고 이야기한다.
* I/O Device
    *  예를 들어 키보드를 뚜드리면 컴퓨터로 정보가 들어가는데 이러한 것들을 인풋 디바이스라고 한다.
    * 하드 디스크도 인풋 디바이스로의 역할도 하고 디스크의 파일시스템에 저장을 하는 역할도 한다. 따라서 아웃풋 디바이스의 역할도 동시에 하는 장치로 보면 된다.
    * 그리고 이러한 각각의 I/O Device들은 각각의 CPU가 존재하는데, 이것을 `디바이스 컨트롤러`라고 부르게 된다. 따라서 디스크의 내부를 통제하는 것이 CPU가 아니라 디스크에 붙어있는 디바이스 컨트롤러가 통제하는 작업을 하게 된다. (키보드도 마찬가지)
    * CPU의 작업공간에 메모리가 있듯이 디바이스 컨트롤러에도 작업공간이 존재하는데, 이것을 `로컬 버퍼`라고 부른다. 
    * 디바이스 컨트롤러는 CPU에 비해서 처리속도가 느리다.
* CPU
    * CPU안에는 메모리보다 빠르면서 정보를 저장할 수 있는 작은 공간을 레지스터라고 부른다.
    * CPU안에 mode bit이 존재하는데 실행하는 작업이 운영체제인지 응용 프로그램인지 구분해주는 역할을 한다.
    * Interrupt line의 존재 이유
        * CPU는 항상 메모리에 있는 인스트럭션만 실행을 한다. 인스트럭션 하나를 실행하고 나면 다음번에 실행할 인스트럭션, 즉 기계어의 주소값이 증가하게되고, 다음 사이클에서는 그 다음 인스트럭션을 실행하고... 이런 역할만 계속 해주게 된다.
        * 키보드에서 어떤 입력이 들어왔다던지 디스크에서 뭘 읽어와야된다던지, 이런 작업들이 끝났는지 어떻게 아는지 구별해주는 것이 Interrupt line이다.
    * CPU는 일처리가 굉장히 빠른 일꾼이지만, 메모리하고만 작업하는 것이 특징이다.
* Timer
    * 특정 프로그램이 CPU를 독점하는 것을 막기 위한 하드웨어이다.
    * 그래서 처음에는 운영체제가 CPU를 가지고 있다가 여러 프로그램이 실행이 되면 그 프로그램한태 CPU를 넘겨주게 된다. 이때 그냥 넘겨주는 것이 아니라 타이머 어떤 값을 세팅한 다음에 CPU에게 작업을 넘겨주게 된다.
    * 그럼 사용자 프로그램은 독점적으로 CPU를 계속 쓸 수 있는 것이 아니라 타이머에 할당된 시간을 세팅해서 작업을 넘겨주기 때문에 시간제한이 걸리는 것이다.
    * 작업을 처리하다 세팅된 시간이 되면 타이머가 CPU한태 interrupt를 건다. 
    * 일정시간 후 자동적으로 OS한태 CPU 제어권이 넘어가게 된다.
    * 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터러브를 발생시킨다.
    * 타이머는 매 클럭 틱 때마다 1씩 감소한다. 이 때 타이머의 값이 0이 되면 타이머 인터럽트가 발생하게 된다.
    * CPU를 특정 프로그램이 독점하는 것으로부터 보호한다.
* Mode Bit
    * CPU에서 기계어를 실행할 때, OS가 실행하는 것인지, 사용자 프로그램이 실행하는 것인지 구분하는 역할을 한다.
    * CPU가 사용자 프로그램에 넘어가면 운영체제는 CPU를 제어할 방법이 없다.
        * 제어하는 기계어도 CPU에서 실행될 때 의미가 있는데, CPU에 넘어가 있기 때문이다.
    * 따라서 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위해 mode bit은 보호장치로 사용된다.
    * 사용자 프로그램에 CPU를 넘길 때, mode bit을 1로 변경후 넘긴다. 그러면 사용자 모드에서 권한이 없는 기계어를 실행하고자 할 때 (Exception) CPU는 자동으로 운영체제에게 넘어간다.

> ### Mode bit을 통해 하드웨어적으로 두가지 모드의 poration 지원
> 1 사용자 모드: 사용자 프로그램 수행 </br>
> 0 모니터 모드: OS 코드 수행
> * 보안을 해칠 수 있는 중요한 명령어는 모니터모드에서만 수행 가능한 특권명령으로 규정
> * Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 바꾼다.
> * 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 세팅한다.
> ![](https://i.imgur.com/BeWFkBv.png)

* System Call
    * 시스템콜은 사용자 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출하는 것을 의미한다.

![](https://i.imgur.com/gkWnr77.png)

* DMA Controller
    * 직접 메모리에 접근할 수 있는 컨트롤러를 의미한다.
    * CPU도 메모리도 접근할 수 있게 된다.
    * 메모리 공간의 교통정리는 메모리 컨트롤러가 담당하게 된다.
    * 기존에 CPU 입장에서 인터럽트가 너무 빈번하게 들어오니까 하던 일을 멈추고 인터럽트에 해당하는 local buffer에 접근해서 카피, 메모리에 올리고 일을 처리하게 되는데, 아주 작은 단위까지 계속해서 이런 방식으로 반복하는 것은 비효율적이라는 것이다.
    * 따라서 DMA는 CPU가 방해받는 것을 막기 위해 존재한다.
        * 일정 수준 까지는 인터럽트가 발생해도 DMA가 local buffer에서 카피를 해와서 메모리에 올려주는 작업까지 해준다.
        * 일정 수준이 넘어가면 인터럽트를 발생시킨다. 따라서 인터럽트 발생 빈도가 낮아지고 CPU를 더욱 효율적으로 사용할 수 있게 된다.
    * 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킨다.

* Device Controller
    * I/O device controller
        * 해당 I/O 장치유형을 관리하는 일종의 작은 CPU
        * 제어 정보를 위해 control register, status register를 가짐
        * local buffer를 가짐 (일종의 data register)
    * I/O는 실제 device와 local buffer 사이에서 일어남
    * Device controller는 I/O가 끝났을 경우 인터럽트로 CPU에 그 사실을 알림

> ### 용어정리
> `device driver (장치구동기)` : OS 코드 중 각 장치별 처리 루틴 -> software </br>
> `device controller (장치제어기)` : 각 장치를 통제하는 일종의 작은 CPU -> hardware

* 입출력(I/O)의 수행
    * 모든 입출력 명령은 특권 명령
    * 사용자 프로그램은 어떻게 I/O를 하는가?
        * 시스템콜(system call)
            * 사용자 프로그램은 운영체제에게 I/O 요청
        * trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
        * 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
        * 올바른 I/O 요청인지 확인 후 I/O 수행
        * I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김
 
* 인터럽트 (Interrupt)
    * 인터럽트 당한 시점의 레지스터와 프로그램 카운터를 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.
    * Interrupt (넓은 의미)
        * interrupt(하드웨어 인터럽트) : 하드웨어가 발생시킨 인터럽트
        * Trap(소프트웨어 인터럽트)
            * Exception : 프로그램이 오류를 범한 경우
            * System call : 프로그램이 커널 함수를 호출하는 경우

> ### 인터럽트 관련 용어
> `인터럽트 벡터` : 해당 인터럽트의 처리 루틴 주소를 가지고 있음  </br>
> `인터럽트 처리 루틴 (Interrupt Service Routine, 인터럽트 핸들러)` : 해당 인터럽트를 처리하는 커널 함수

